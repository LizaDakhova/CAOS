(язык разметки: markdown, codepage: utf-8)

Способ запуска (для примера, ваша программа называется strings):

* ./strings < test-1 > res1.txt

Сравнение:

* diff res1.txt test-1-res.txt

У вас могут быть лишние "отладочные" строки, но расхождение в главном блоке говорит об ошибке

Кратко по тестам:
* test-koi, test-eof — работают одинаково для всех вариантов
* test-small — приведен ответ для варианта, где кавычки несут отдельную функцию.
* test-err: для варианта, где кавычки с особой функцией, должен сообщить об ошибке (совсем хорошо, если в stderr)
  * Для вывода строки в stderr можно использовать: `fputs("строка",stderr)`
* test-sort: простой пример на сортировку
* test-err: для варианта, где кавычки с особой функцией, должен сообщить об ошибке (совсем хорошо, если в stderr)
* test-1, test-2, test-tricky: варианты для задания на 10


Проверка на память.

1. Создать файл из большого числа строк (здесь — 1000): 
  * for i in `seq 1 1000`; do echo "string-template" ; done > many-strings

Эталонный ответ будет: взять каждую строку и обрамить в кавычки. Это можно сделать так: ```
sed -e 's#\(.*\)#"\1"#' < many-strings > many-strings-res.txt
```
Для понимания происходящего читать: методички по шелл (Робачевский или «Unix shell: первые шаги», man sh, man sed, man seq, man yes

2. На длинную строку (здесь — 1000*длина-шаблона символов):
  * ```
( for i in `seq 1 1000`; do echo -n "string-template" ; done ; echo ) > long-string
```

Эталонный ответ получается аналогично: sed -e 's#\(.*\)#"\1"#' < long-string > long-string-res.txt
